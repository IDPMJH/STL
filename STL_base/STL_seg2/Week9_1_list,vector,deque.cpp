#define Prac 3
// 
// 
// [이번 내용]
// array<T, N>
// vector<T>
// list<T>
// deque<T> - vector보다 더 많은 원소를 담을 수 있다.
//
//	

#include "STRING.h"
using namespace std;
extern bool inspect;

#if Prac == 1
#include <iostream>
#include <vector>
#include <deque>
#include <list>

// =======================================================================
// [문제] vector erase 시 그림 그려라 ★★★★★★
// 혹은 emplace_back시?
//========================================================================

int main()
{
	vector<STRING> v{ "1","22", "333","4444","55555" };

	/*inspect = true;
	erase(v, "333");
	inspect = false;*/

	/*(erase)시 일어나는 일
	[      11] 생성자(char*)    자원 수:3          메모리:0x6c69b2fb90 자원메모리:0x1b792e46400
	[      11] 소멸자           자원 수:3          메모리:0x6c69b2fb90 자원메모리:0x1b792e46400
	[      12] 생성자(char*)    자원 수:3          메모리:0x6c69b2fb90 자원메모리:0x1b792e46440
	[      12] 소멸자           자원 수:3          메모리:0x6c69b2fb90 자원메모리:0x1b792e46440
	[      13] 생성자(char*)    자원 수:3          메모리:0x6c69b2fb90 자원메모리:0x1b792e46510
	[      13] 소멸자           자원 수:3          메모리:0x6c69b2fb90 자원메모리:0x1b792e46510
	[      14] 생성자(char*)    자원 수:3          메모리:0x6c69b2fb90 자원메모리:0x1b792e463b0
	[      14] 소멸자           자원 수:3          메모리:0x6c69b2fb90 자원메모리:0x1b792e463b0
	[       8] 이동할당연산자    자원 수:4          메모리:0x1b792e41f80 자원메모리:0x1b792e46480
	[      15] 생성자(char*)    자원 수:3          메모리:0x6c69b2fb90 자원메모리:0x1b792e46450
	[      15] 소멸자           자원 수:3          메모리:0x6c69b2fb90 자원메모리:0x1b792e46450
	[       9] 이동할당연산자    자원 수:5          메모리:0x1b792e41f98 자원메모리:0x1b792e46540
	[      10] 소멸자           자원 수:0          메모리:0x1b792e41fb0 자원메모리:0x0
	*/

	// 그림그리는 단계
	list<STRING> v2{ "1","22", "333","4444","55555" };

	// 이름있는 객체는 v2 뿐, "1" 등은 이름 없는 객체
	// v2는 x64/release에서 40바이트, 스택에 생성, 노드가 5개 free-store에 생성됨 (list이기 때문에 캐시지역성이 낮음)
	// {}이니셜라이저를 통해 초기화 -> 6번, 7번...10번 등 번호가 붙고 이전노드와 뒤 노드를 가리키는 포인터 두개가 있음
	// 따라서 노드의 크기도 24(STRING크기) + 포인터(8바이트)2개 = 40바이트
	// 또 각각의 노드의 STRING 이 가리키는 포인터가 있어서 복잡함
	// v2의 3번 객체의 해제 => 8번 id의 해제, 리스트는 삭제될 노드를 가리키는 포인터만 수정해주면 됨(이전노드와 이후노드)
	// 
	// 
	/*inspect = true;
	erase(v2, "333");
	inspect = false;*/
	// 왜 벡터마냥 생성 소멸이 여러번 일어나는가?
	// STL은 Container 와 Algorithm이 Iterator를 통해 의사소통함
	// erase(v2,"333"); syntactic sugar 꿀문법이며, 이 안에는 반복자가 들어가 반복자를 알 수 있음
	// 반복자를 통해 알고리즘은 컨테이너에 순차접근하여 찾는다.
	// 따라서 알고리즘은 컨테이너의 구조를 모르기 때문에, 리스트의 장점인 erase의 기능을 온전히 활용하지 못한다.
	// erase(remote(list.begin(),list.end(),"333) (operator ==을 사용)
	// 따라서 컨테이너의 장점을 활용하기 위해서는 본인이 직접 제공하는 함수를 사용한다.
	
	inspect = true;
	v2.remove("333");	// 임시 객체 11번 "333"을 생성하여 컨테이너의 원소와 비교한다 .
	inspect = false;

	/*for (const STRING& str : v2)
	{
		cout << str << endl;
	}*/


}

#elif Prac == 2
#include <iostream>
#include <deque>
#include <vector>

// =======================================================================
// [문제] vector와 deque의 차이점
//========================================================================


int main()
{
	// 데이터 1000개를 만들자.
	vector<STRING> v;	// 단일 contiguous 메모리				0...9999까지 연속된 공간을 제공	
	v.reserve(10000);
	deque<STRING> d;	// block으로 연결한 contiguous memory	[0,1,2,4] [5,6,7,8] ,[9,10,11,12] ... [9996,9997,9998,9999] => 이중연결리스트로 구성

	// 둘 다 subscript 오퍼레이터, index오퍼레이터, []를 제공함
	// []의 의미는 컨테이너가 contiguous, access가 O(1)을 가짐을 의미
	// 근데 deque는 연결리스트인데 O(1), []이 어떻게 가능함?
	// 둘 다 dynamic메모리 액세스 구조이며, Memory Manager에게 부탁함
	// Memory Manager는 사용 중인 메모리의 목록을 연결리스트,테이블 등으로 저장함 (유지 관리)
	// Memory Manager에게 요청하는 메모리는 항상 contiguous메모리
	// 이러면 조각화 fragmentation, segmentaion문제가 발생함
	// 이러한 상황에서 필요한 용량의 비어있는 연속적인 공간이 없으면 벡터는 사용할 수 없음
	// 그러나 deque는 조각난 용량들(블럭)을 연결하여 구성되어 사용 가능함

	// 결론:
	// vector와 deque가 있다면
	// vector는 []access "속도"가 deque보다 항상 "빠르다".
	// deque가 원소를 훨씬 많이 담을 수 있는 "가능성"이 크다.
	// 극단으로 내려오면 list가 있음 - 메모리 블럭이 점점 작아진 경우

	// STL : 
	// 1. Sequence (array제외 나머지는 freestore에서 관리)
	//		1.1 - array	-> 고정
	//		1.2 - vector-> 단일 블럭	[1....N]
	//		1.3 - deque	-> 여러 블럭	[1,2,3,4] -> ....->[. . . N]	// 특히 안의 원소를 지우거나 추가하기 힘든 것은 벡터와 마찬가지
	//		1.4 - list	-> 노드		[1] -> [2] ->...->[N}			// 안의 원소를 지우거나 추가하기가 매우 용이함
	// 2. Associate
	// 3. Unordered

	// sort알고리즘이 매우 중요하다.
	// 벡터 sort시 swap동작을 실행(이동 생성자 사용) - 알아볼 것
	// 리스트 sort시
	// [1] -> [3] -> [2] -> [5] 였을 때,
	// [1] -> [2] -> [3] -> [5]로 정렬하는데 빠를 수 있음
	// list의 동작방식 때문에 리스트의 sort는 list.sort의 직접 제공으로 사용한다.
	v[500];
}



#elif Prac == 3
#include <iostream>
#include <list>
#include <vector>
#include <algorithm>
#include <ranges>

// =======================================================================
//[문제] list 파악하기
//========================================================================

int main()
{
	inspect = true;
	list<STRING> cont{"1","22", "333", "4444", "55555"};
	vector<STRING> v{ "1","22", "333", "4444", "55555" };
	vector<string> v3{ "1","22", "333", "4444", "55555" };
	vector<int> v2{ 1,2,3,4,5,3 };
	// id 6~ 10 까지가 실질적으로 리스트에 들어가있는 객체임
	inspect = false;

	// 할 수 없는 동작 (list이기 때문에)
	// sort(cont.begin(),cont.end()) 빨간줄은 안 뜨지만, 이는 컴파일 전에 컨테이너가 뭔지 몰라서 그럼
	ranges::sort(v2);
	//ranges::sort(v3);
	//ranges::sort(cont.begin());
	for (const STRING& s : cont)
		cout << s << endl;

}


#elif Prac == 4
#include <iostream>



// =======================================================================
//
//========================================================================

int main()
{

}


#elif Prac == 5
#include <iostream>



// =======================================================================
//[문제] 
//========================================================================

int main()
{

}

#elif Prac == 6
#include <iostream>

// =======================================================================
//[문제] 
//========================================================================

int main()
{

}

#elif Prac == 7
#include <iostream>
#include <deque>

// =======================================================================
//[문제] 
//========================================================================

int main()
{

}



#endif