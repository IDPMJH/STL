#define Prac 1
// ★★★시험 == 8주 2일, 4월 24일(30점), 과제 == (30점) - 4월 10일 설명
// 5월 6일(화) -> 6월 19일(예정)
// =================이전 주제=================
// STRING - std::string가 유사한 클래스, STL 표준 컨테이너가 되도록..
//	내부 동작을 관찰할 수 있게 하자.
// 
// =================이번 주제=================
// 이동 생성과 이동할당연산자 로딩
// 
//
#include "STRING.h"
using namespace std;

#if Prac == 1
#include <iostream>

extern bool inspect;
// =======================================================================
//[문제] 아래 코딩이 정상적으로 실행되도록 수정
//========================================================================

int main()
{
	inspect = true;
	//string s{ "표준 string" };
	//string t = move(s);

	STRING s2{ "마이 스트링" };
	STRING t2 = move(s2);	
	// move semantic , std::move 함수는 이동을 수행하지 않는다.
	// 그냥 인자로 받은 객체를 우측값으로 변환할 뿐이다.
	// 자원을 이동당한 객체(s2)의 명칭 : xvalue
	// C++ value category (cpp reference)
	// 표현식의 구성 (구식, 현재는 찾아볼 것)
	// 1. glvalue : = 의 왼쪽 값은 메모리 저장소이다. => location value
	// 2. rvalue :  = 프로그램에서 접근할 수 있는 주소가 없는 값.
	
	// 복사 생성자가 호출된 이유 -> 이동에 관련된 동작을 정의하지 않았기 때문에 대신 복사 생성자를 호출

	// 자원을 이동당한 객체는, 컴파일러는 사용하지 않는 객체로 판별 (expired instance)
	// => xvalue를 cout했을 때 경고가 떴던 이유
	cout << "s - " << s2 << endl;	// 주의: xvlaue인 s2를 참조하지 않도록 s2의 멤버변수를 신경쓰자
	cout << "t - " << t2 << endl;
}
#elif Prac == 2


int main()
{
	int r;
	int num;
	int& a = num;	// 레퍼런스 오브 num
	int* p = &num;	// 어드레스 오브 num
}


#elif Prac == 3
#include <array>
#include <algorithm>
#include <print>
#include <iostream>

extern bool inspect;
// =======================================================================
//[문제]라이브러리 - 많이 쓰는 기능을 다시 쓸 수 있도록 미리 컴파일해둔 코드의 집합, 링크해서 사용함
// c언어의 라이브러리 - 소스코드가 보이지 않는 기계어의 집합
// C++의 라이브러리 - 실제 소스코드가 보임
//========================================================================

int main()
{	
	inspect = true;
	
	array<STRING, 5> a{ "1","333","55555","22","4444" };

	// 정렬
	sort(a.begin(), a.end(), [](const STRING& lhs, const STRING& rhs) 
		{
			return lhs.size() < rhs.size(); 
		});
	// 출력

	/*
	std::sort는 요소의 이동 생성자/이동 할당 연산자를 반복적으로 호출하여 요소들의 위치를 바꿉니다.

	이 과정에서 임시 객체가 이동 생성되고, 기존 객체에 이동 할당이 발생하며, 임시 객체가 소멸됩니다.
	
	따라서, 정렬 과정에서 다수의 이동생성자, 이동할당연산자, 소멸자 로그가 출력되는 것이 정상적인 동작입니다.
	
	이는 C++11 이후 move semantics를 적극적으로 활용하는 현대 C++ 라이브러리의 표준적인 동작 방식입니다
	*/
	
	// for loop에 auto는 되도록 지양 - const &를 붙이더라도 가독성의 문제 
	for (const STRING& str : a)	
		cout << str << endl;
}


#elif Prac == 4



// =======================================================================
//[문제]
//========================================================================

int main()
{



}


#elif Prac == 5



// =======================================================================
//[문제]
//========================================================================

int main()
{


}


#endif